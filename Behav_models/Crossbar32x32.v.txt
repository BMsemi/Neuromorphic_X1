// ------------------------------------------------------------
// Digital-compatible behavioral model of a 32x32 1T1R RRAM array
// Designed for functional simulation of memory arrays
// 
// - Each bitcell consists of a resistive memory (RRAM) and a select transistor
// - WL: activates access transistor (gate)
// - SL: source line used to write data (SET/RESET)
// - BL: bitline read out (grounded by sense amp during read)
// 
// Operation:
// - Write '1': WL=1, SL=1, BL=0 → SET (low resistance)
// - Write '0': WL=1, SL=0, BL=0 → RESET (high resistance)
// - Read: WL=1, SL=1, BL is sensed → if memory=1, SL drives BL low
// 
// Note: This model is simplified for digital simulation only.
// It does not simulate physical behavior or analog dynamics.
// ------------------------------------------------------------

// Digital-compatible binary 1T1R cell with correct selection scheme
module rram_access_cell(WL, SL, BL);
    input WL;         // Word Line: activates transistor gate
    input SL;         // Source Line: applies voltage for read/write
    inout BL;         // Bit Line: grounded by sense amplifier during read

    reg memory_state; // 1: Low Resistance (ON), 0: High Resistance (OFF)

    // Reading: Cell pulls BL line low if selected and ON
    assign BL = (WL && memory_state) ? SL : 1'bz;

    always @(posedge WL) begin
        // Write behavior: SL driven high externally to set the cell to ON state
        if (SL && (BL === 1'b0))
            memory_state <= 1'b1;  // SET operation
        else if (!SL && (BL === 1'b0))
            memory_state <= 1'b0;  // RESET operation
    end
endmodule

// Top-level custom digital crossbar array
module crossbar32x32(WL, SL, BL);
    input [31:0] WL;
    input [31:0] SL;
    inout [31:0] BL;

    genvar i, j;
    generate
        for (i = 0; i < 32; i = i + 1) begin: rows
            for (j = 0; j < 32; j = j + 1) begin: cols
                rram_access_cell cell (
                    .WL(WL[i]),
                    .SL(SL[i]),
                    .BL(BL[j])
                );
            end
        end
    endgenerate
endmodule